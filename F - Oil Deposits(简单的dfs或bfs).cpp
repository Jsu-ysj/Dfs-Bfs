/**
题目简介：
在第一次植物僵尸世界大战中，植物国的黑玫瑰王子使用了植物国的超超超超级无敌禁术-----”BUG”,开启了异次元的大门，
在一位超超超超...级**的指挥官”辅助器”带领下，打败了僵尸王国，但是也因此植物国大伤元气，无法再得到异次元的帮助。
过了10000年后，僵尸国王子为了国家的荣誉和发扬祖先的”诺克萨斯”精神，打算采取”闪电战”战术，一举歼灭植物国的战略要塞，
吹起第二次植物僵尸世界大战的号角，但是僵尸王子需要知道植物国现在有几个战略要塞，才能采取进一步措施，
于是开始研究植物国的军事图。
因为僵尸国卫星技术先进，该军事图十分清楚明了，是一个二维的电子网格图，图中只有黑色和白色，
只要图中的白色方块外一圈的八个方块中有白色方块，说明它们属于同一个战略要塞。

Input
多组输入（m = 0结束输入）。
军事图是m*n的二维图，图中”@”表示白色，”*”表示黑色。

第一行包含m,n（1<=n,m<=100）,
接下来m行，每行n个字符。

Output
对于每组输入，输出植物国的战略要塞数量。
Sample Input
1 1
*
3 5
*@*@*
**@**
*@*@*
1 8
@@****@*
5 5
****@
*@@*@
*@**@
@@@*@
@@**@
0 0 
Sample Output
0
1
2
2
**/

/**
思路： 这题比较简单， 直接dfs遍历@处，遇到在范围内的@,变成#表示无效即可； 
**/

//具体代码：
#include<bits/stdc++.h>
using namespace std;
const int N = 1e3+10;
char mp[N][N];
int to[8][2]{{ -1, -1 }, { -1, 0 }, { -1, 1 }, { 0, -1 }, { 0, 1 }, { 1, -1 }, { 1, 0 }, { 1, 1 } };
int n, m;
void dfs(int now_x, int now_y){
	for(int i = 0; i < 8; i++){
		int next_x = now_x + to[i][0];
		int next_y = now_y + to[i][1];
		if(mp[next_x][next_y]=='@'){
			mp[next_x][next_y] = '#';
			dfs(next_x, next_y);
		}
	}
}
int main(){
	while(cin >> m >> n && m){
		int ans = 0;
		for(int i = 1; i <= m; i ++){
			for(int j = 1; j <= n; j ++){
				cin >> mp[i][j];
			}
		}
		for(int i = 1; i <= m; i ++){
			for(int j = 1; j <= n; j ++){
				if(mp[i][j] == '@'){
					mp[i][j] = '#';
					dfs(i, j);
					ans ++;
				}
			}
		}
		cout << ans << endl;
	}
	return 0;
} 
